//  USRDecoder.swift
//  SwiftStaticAnalysis
//  MIT License

import RegexBuilder

// MARK: - USR Type Context Pattern

/// Matches Swift USR type context pattern: `s:<length><name><kind-marker>`
///
/// Examples:
/// - `s:14NetworkMonitorC` - Class
/// - `s:7MyModelV` - Struct
/// - `s:6StatusO` - Enum
/// - `s:10MyProtocolP` - Protocol
///
/// Captures the kind marker character (C/V/O/P).
private nonisolated(unsafe) let usrTypeContextRegex = Regex {
    "s:"
    OneOrMore(.digit)
    OneOrMore(.word)
    Capture {
        One(CharacterClass.anyOf("CVOP"))
    }
}

// MARK: - USRDecoder

/// Decodes USR (Unified Symbol Resolution) strings.
///
/// USRs are stable, unique identifiers for symbols generated by the compiler.
/// They encode the symbol's module, scope, name, type, and modifiers.
///
/// Example Swift USR: `s:14NetworkMonitorC6sharedACvpZ`
/// - `s:` - Swift schema
/// - `14NetworkMonitor` - Context (length-prefixed)
/// - `C` - Class kind marker
/// - `6shared` - Symbol name (length-prefixed)
/// - `AC` - Return type
/// - `vp` - Variable property
/// - `Z` - Static modifier
public struct USRDecoder: Sendable {
    /// Creates a new USR decoder.
    public init() {}

    /// Decoded USR components.
    public struct DecodedUSR: Sendable, Hashable {
        /// The schema (swift or clang).
        public let schema: Schema

        /// The containing type name, if any.
        public let contextName: String?

        /// The symbol name.
        public let symbolName: String

        /// The symbol kind.
        public let kind: Kind

        /// Whether this is a static member.
        public let isStatic: Bool

        /// Whether this is an instance member.
        public let isInstance: Bool

        /// The full USR string.
        public let rawUSR: String
    }

    /// USR schema types.
    public enum Schema: String, Sendable {
        case swift = "s"
        case clang = "c"
    }

    /// Symbol kinds decoded from USR.
    public enum Kind: String, Sendable {
        case variable = "v"
        case function = "F"
        case method = "f"
        case property = "p"
        case type = "C"  // Class/Actor
        case `struct` = "V"
        case `enum` = "O"
        case `protocol` = "P"
        case initializer = "c"
        case deinitializer = "D"
        case `subscript` = "i"
        case `operator` = "o"
        case unknown
    }

    /// Decodes a USR string into its components.
    ///
    /// - Parameter usr: The USR string to decode.
    /// - Returns: Decoded components, or `nil` if invalid.
    public func decode(_ usr: String) -> DecodedUSR? {
        guard usr.count > 2 else { return nil }

        // Parse schema
        let schemaChar = String(usr.prefix(1))
        guard usr.dropFirst().first == ":" else { return nil }

        let schema: Schema
        switch schemaChar {
        case "s":
            schema = .swift
        case "c":
            schema = .clang
        default:
            return nil
        }

        // For Swift USRs, try to extract key information
        if schema == .swift {
            return decodeSwiftUSR(usr)
        } else {
            return decodeClangUSR(usr)
        }
    }

    /// Decodes a Swift USR.
    private func decodeSwiftUSR(_ usr: String) -> DecodedUSR? {
        let content = String(usr.dropFirst(2))  // Remove "s:"
        guard !content.isEmpty else { return nil }

        // Check for static modifier (trailing Z)
        let isStatic = usr.hasSuffix("Z")

        // Extract context and symbol names using length-prefixed parsing
        var index = content.startIndex
        var contextName: String?
        var symbolName: String?

        // Try to parse length-prefixed components
        while index < content.endIndex {
            guard let (name, nextIndex) = parseLengthPrefixed(content, from: index) else {
                break
            }

            // First component is typically the context, second is the symbol
            if contextName == nil {
                contextName = name
            } else if symbolName == nil {
                symbolName = name
            }

            index = nextIndex

            // Stop if we hit a non-digit character that isn't a length prefix
            if index < content.endIndex {
                let nextChar = content[index]
                if !nextChar.isNumber {
                    // Check for kind markers
                    if let kindEndIndex = findKindMarker(content, from: index) {
                        index = kindEndIndex
                    } else {
                        break
                    }
                }
            }
        }

        // Determine kind from USR patterns
        let kind = inferKind(from: usr)

        // If we couldn't parse names, use heuristics
        let finalSymbolName = symbolName ?? extractFallbackName(usr)
        let isInstance = !isStatic && (kind == .method || kind == .property)

        return DecodedUSR(
            schema: .swift,
            contextName: contextName,
            symbolName: finalSymbolName,
            kind: kind,
            isStatic: isStatic,
            isInstance: isInstance,
            rawUSR: usr
        )
    }

    /// Decodes a Clang USR.
    private func decodeClangUSR(_ usr: String) -> DecodedUSR? {
        // Clang USRs have a different format
        // For now, extract basic information
        let content = String(usr.dropFirst(2))

        return DecodedUSR(
            schema: .clang,
            contextName: nil,
            symbolName: content,
            kind: .unknown,
            isStatic: false,
            isInstance: false,
            rawUSR: usr
        )
    }

    /// Parses a length-prefixed string component.
    ///
    /// Format: `<length><string>` where length is decimal digits.
    private func parseLengthPrefixed(
        _ string: String,
        from startIndex: String.Index
    ) -> (String, String.Index)? {
        var index = startIndex
        var lengthString = ""

        // Collect digits
        while index < string.endIndex && string[index].isNumber {
            lengthString.append(string[index])
            index = string.index(after: index)
        }

        guard !lengthString.isEmpty,
            let length = Int(lengthString),
            length > 0
        else {
            return nil
        }

        // Extract the name
        let endIndex =
            string.index(index, offsetBy: length, limitedBy: string.endIndex)
            ?? string.endIndex
        let name = String(string[index..<endIndex])

        guard name.count == length else {
            return nil
        }

        return (name, endIndex)
    }

    /// Finds and skips over kind marker characters.
    private func findKindMarker(
        _ string: String,
        from startIndex: String.Index
    ) -> String.Index? {
        let kindMarkers: Set<Character> = ["C", "V", "O", "P", "F", "f", "v", "p", "c", "D", "i", "o"]

        var index = startIndex
        while index < string.endIndex && kindMarkers.contains(string[index]) {
            index = string.index(after: index)
        }

        return index != startIndex ? index : nil
    }

    /// Infers the symbol kind from USR patterns.
    private func inferKind(from usr: String) -> Kind {
        // Check for common patterns
        if usr.contains("vp") {
            return .property
        }
        if usr.contains("fC") || usr.contains("fc") {
            return .method
        }
        if usr.contains("cC") || usr.contains("cc") {
            return .initializer
        }
        if usr.contains("FC") {
            return .function
        }
        // Type markers at context position using RegexBuilder
        if let match = usr.firstMatch(of: usrTypeContextRegex) {
            let marker = match.output.1
            switch marker {
            case "C": return .type  // Class/Actor
            case "V": return .struct
            case "O": return .enum
            case "P": return .protocol
            default: break
            }
        }
        return .unknown
    }

    /// Extracts a fallback name when parsing fails.
    private func extractFallbackName(_ usr: String) -> String {
        // Try to find the last length-prefixed component
        let content = String(usr.dropFirst(2))

        // Find sequences of digits followed by letters
        var lastMatch = ""
        var i = content.startIndex

        while i < content.endIndex {
            if content[i].isNumber {
                var lengthStr = ""
                var j = i
                while j < content.endIndex && content[j].isNumber {
                    lengthStr.append(content[j])
                    j = content.index(after: j)
                }

                if let length = Int(lengthStr), length > 0 {
                    let end = content.index(j, offsetBy: length, limitedBy: content.endIndex) ?? content.endIndex
                    let candidate = String(content[j..<end])
                    if candidate.count == length && candidate.allSatisfy({ $0.isLetter || $0.isNumber || $0 == "_" }) {
                        lastMatch = candidate
                    }
                    i = end
                    continue
                }
            }
            i = content.index(after: i)
        }

        return lastMatch.isEmpty ? "unknown" : lastMatch
    }
}
